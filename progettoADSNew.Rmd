---
title: "Analisi bibliometrica - I docenti del DMIF"
author: "Claudia Costa"
date: "`r Sys.Date()`"
css: stileProgetto.css
output: 
  rmdformats::readthedown:
  highlight: kate
editor_options: 
  markdown: 
    wrap: 72
bibliography: references.bib
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)
#knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
## Global options
options(max.print=2000)
knitr::opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

```{r img uniud, echo=FALSE}
htmltools::img(src = knitr::image_uri("dmif.png"), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px;')
```

```{r caricamento librerie, include=FALSE}
library(bibliometrix)
library(dplyr)
library(ggplot2)
library(tidyverse) # Collection of all the good stuff like dplyr, ggplot2 ect.
library(magrittr) # For extra-piping operators (eg. %<>%)
library(data.table) # Good format to work with large datasets
library(skimr) # Nice descriptives
library(igraph) # Network analysis
library(tidygraph) # Tidy network analysis
library(ggraph) # ggplot-like nw plotting
library(Matrix)
library(purrr)
library(plotly)
library(htmltools)
library(multigraph)
library(wordcloud2)
library(wordcloud)
```

```{r script plot, include=FALSE}
source("plot.bibliometrix.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

```{r script plot2, include=FALSE}
source("authorProdOverTime.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

```{r script summary, include=FALSE}
source("summary.bibliometrix.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

```{r script zzz, include=FALSE}
source("zzz.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

```{r script histPlot, include=FALSE}
source("histPlot.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

```{r script networdPlot, include=FALSE}
source("networkPlot.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

# Introduzione

<!-- nuovo file con cose inutili tolte -->

<!-- uso file CSV filtrato con i docenti scelti a mano (serve la lista?), scaricati il 12/02/2024 (nuovo: 24/04/2024)
query usata su scopus: AF-ID ( "Universit&#224; degli Studi di Udine" 60025965 ) AND SUBJAREA ( comp ) AND ( LIMIT-TO ( PREFNAMEAUID , "Montanari, A.#7101889543" ) OR LIMIT-TO ( PREFNAMEAUID , "Chittaro, L.#7004119007" ) OR LIMIT-TO ( PREFNAMEAUID , "Mizzaro, S.#6603594721" ) OR LIMIT-TO ( PREFNAMEAUID , "Dovier, A.#6603827082" ) OR LIMIT-TO ( PREFNAMEAUID , "Policriti, A.#6701331312" ) OR LIMIT-TO ( PREFNAMEAUID , "Miculan, M.#6602346936" ) OR LIMIT-TO ( PREFNAMEAUID , "Piazza, C.#56228866500" ) OR LIMIT-TO ( PREFNAMEAUID , "Piciarelli, C.#9039137600" ) OR LIMIT-TO ( PREFNAMEAUID , "Fontana, F.#55970349500" ) OR LIMIT-TO ( PREFNAMEAUID , "Lancia, G.#6701584197" ) OR LIMIT-TO ( PREFNAMEAUID , "Formisano, A.#7003786950" ) OR LIMIT-TO ( PREFNAMEAUID , "Roitero, K.#57191042663" ) OR LIMIT-TO ( PREFNAMEAUID , "Scagnetto, I.#56242036400" ) OR LIMIT-TO ( PREFNAMEAUID , "Brajnik, G.#6603009854" ) OR LIMIT-TO ( PREFNAMEAUID , "Serra, G.#10140344600" ) OR LIMIT-TO ( PREFNAMEAUID , "Ranon, R.#6603216942" ) OR LIMIT-TO ( PREFNAMEAUID , "Franceschet, M.#6603459161" ) OR LIMIT-TO ( PREFNAMEAUID , "Mirolo, C.#6603641510" ) OR LIMIT-TO ( PREFNAMEAUID , "Della Mea, V.#7003376592" ) OR LIMIT-TO ( PREFNAMEAUID , "Buttussi, F.#16229748200" ) OR LIMIT-TO ( PREFNAMEAUID , "Geatti, L.#57204585138" ) OR LIMIT-TO ( PREFNAMEAUID , "D&apos;Agostino, G.#35617431600" ) OR LIMIT-TO ( PREFNAMEAUID , "Della Monica, D.#57195719517" ) OR LIMIT-TO ( PREFNAMEAUID , "Maddalena, E.#56382377600" ) OR LIMIT-TO ( PREFNAMEAUID , "Casagrande, A.#23395669600" ) OR LIMIT-TO ( PREFNAMEAUID , "Comini, G.#7005313868" ) OR LIMIT-TO ( PREFNAMEAUID , "Puppis, G.#6507419503" ) OR LIMIT-TO ( PREFNAMEAUID , "Mea, V.D.#7003376592" ) OR LIMIT-TO ( PREFNAMEAUID , "Soprano, M.#57203392311" ) OR LIMIT-TO ( PREFNAMEAUID , "Monica, D.D.#57195719517" ) OR LIMIT-TO ( PREFNAMEAUID , "Romanello, R.#57903048800" ) ) -->

```{r}
# uso file bib filtrato con i docenti scelti a mano, scaricati il 15/07/2024
#fileF <- "uniudFiltered (1).bib"
#fileF <- "scopus.txt"
#uniudFilt <- convert2df(file = fileF, dbsource = "scopus", format = "bibtex")
```

```{r caricamento file, include=FALSE}
fileCSV <- "scopus.csv"
#prova <- convert2df(file = fileCSV, dbsource = "scopus", format = "csv")
newProva <- convert2df(file = "scopusJuly.csv", dbsource = "scopus", format = "csv")
#M <- convert2df(file = fileCSV, dbsource = "scopus", format = "csv")
```

## Che cosa è la bibliometria?

La bibliometria è una disciplina che utilizza analisi quantitative e statistiche per analizzare le pubblicazioni scientifiche e le loro relazioni.

Il progetto si focalizza sull'analisi della produzione scientifica dei docenti del dipartimento DMIF dell'Università degli Studi di Udine, per cercare di dare una stima di:

- come funziona la ricerca

- quali sono i settori di maggiore interesse

- gli autori più prolifici.

Per supporto all'analisi ho utilizzato una libreria, [Bibliometrix](https://www.bibliometrix.org/home/) [@bibliometrix], sviluppata da due docenti dell'Università di Napoli.

## Fonte dei dati

I dati analizzati in questo progetto sono stati scaricati (ultimo download: 15/07/2024) da
[Scopus](https://www.scopus.com/search/form.uri?display=basic&zone=header&origin=searchbasic#basic), uno dei principali dabatase bibliografici. E' stata selezionata la sottoarea della computer science e da successivamente sono stati selezionati 31 autori del DMIF, tra docenti e dottorandi.

Ogni articolo del dataframe contiene svariati attributi tra cui: la lista di autori, il titolo del documento, la sorgente di pubblicazione, il tipo di documento, le parole chiavi degli autori, le references, il numero di citazioni, l'anno di pubblicazione.

# Analisi bibliometrica

## Analisi descrittiva del dataframe

La tabella delle informazioni principali descrive le dimensioni della
raccolta in termini di numero di documenti, numero di autori, numero di fonti, numero di parole chiave, durata e numero medio di citazioni.

- "docs per autori" è calcolato come rapporto tra il numero totale di autori e il numero totale di articoli.

- "co-autori per articolo" è calcolato come numero medio di co-autori per articolo.

```{r analisi descrittiva}
results <- biblioAnalysis(newProva, sep = ";")
options(width=100)
S <- summary(object = results, k = 15, pause = FALSE)
gs <- plot.bibliometrix(x = results, k = 15, pause = FALSE)

```


```{r}
ggplotly(gs$MostProdAuthors)
```
Prof. Montanari autore più produttivo con 196 articoli

```{r}
ggplotly(gs$MostProdCountries)
#SCP: Single Country Publications
#MCP: Multiple Country Publications
```
Italia paese più produttivo, alcuni autori erano in altri paesi (esempio Svizzera, UK) quando hanno pubblicato

```{r}
plot(gs$AnnualScientProd)
```

anno più produttivo: 2023 con 87 pubblicazioni

```{r}
plot(gs$AverArtCitperYear)
```

anno con media citazioni in articoli più alta: 2018

```{r}
plot(gs$AverTotCitperYear)
```

anno con più citazioni: 1987


### Documenti per tipo

```{r analisi docs}
newProva %>%
  count(DT, sort = TRUE)

docType <- ggplot(newProva) +
  geom_bar(mapping = aes(x = fct_infreq(DT), fill = DT)) +
  labs(x = "", y = "Number of documents", fill = "Type") +
  theme_bw() +
  theme(legend.position = "bottom", axis.text.x = element_text(angle = -60))

ggplotly(docType)
```

Il tipo di pubblicazione più presente è il conference paper, seguito da articoli e capitoli di libro.

## Analisi dei riferimenti citati

<!-- La funzione citazioni genera la tabella di frequenza dei riferimenti più citati o dei primi autori più citati (dei riferimenti). (nel senso, sono tutte le references degli articoli della collezione) -->

Possiamo analizzare la frequenza dei riferimenti/primi autori più citati nel dataset in analisi.

<!-- La citazione globale rappresenta il numero totale di citazioni ricevute da un documento da tutte le pubblicazioni indicizzate in una fonte - in questo caso il dataset in analisi. -->

Papers citati più frequentemente:
```{r analisi ref}
mostCitedRef <- citations(newProva, field = "article", sep = ";")
cbind(mostCitedRef$Cited[1:10])
```

Vediamo che 2 articoli del Professor Montanari sono tra i più citati.

Primi autori citati più frequentemente:
```{r analisi ref aut}
mostCitedAut <- citations(newProva, field = "author", sep = ";")
cbind(mostCitedAut$Cited[1:15])
#cbind(CR$Cited[c(-2, 1:14)])
```

Vediamo che gli autori più frequentemente citati sono i Professori Montanari, Dovier, Mizzaro e Policriti.

## H-index degli autori

L'h-index è una metrica a livello di autore che cerca di misurare sia la produttività che l'impatto citazionale delle pubblicazioni.

L'indice si basa sull'insieme degli articoli più citati dello scienziato e sul numero di citazioni ricevute in altre pubblicazioni. L'indice è strutturato per quantificare mediante un singolo indice numerico non solo la produzione, ma anche l'influenza di uno scienziato, distinguendolo da chi avesse pubblicato molti articoli ma di scarso interesse.

Quindi uno scienziato ha un indice n se almeno n lavori tra quelli che ha pubblicato sono stati citati almeno n volte ciascuno.

L'indice è definito in modo tale che sull'insieme dato di articoli, ordinati in ordine decrescente di citazioni ricevute, il valore dell'indice-g è assegnato quando i primi g articoli hanno ricevuto cumulativamente $g^2$ citazioni.
$$g^2 \leq \sum_{i \leq g} c_i$$

L' M-index è definito come h/n, dove h è l' H-index e n è il numero di anni trascorsi dalla prima pubblicazione del ricercatore.

```{r}
#indices <- Hindex(prova, field = "author", elements=c("PIAZZA C", "DOVIER A", "ROMANELLO R"), sep = ";", years = 10)

#indices$H
```

```{r}
#indices$CitationList
```

H-index dei primi 10 autori più produttivi (in questa raccolta):

```{r indice h}
authors=gsub(","," ",names(results$Authors)[1:10])

indicesAll <- Hindex(newProva, field = "author", elements=authors, sep = ";", years = 50)

slice(indicesAll$H, order(indicesAll$H$h_index, decreasing = TRUE))
```

Gli autori con l'H-index più alto sono i Prof. Chittaro, Prof. Montanari e Prof. Mizzaro.


# Matrici di rete bibliografica

Gli attributi del paper sono collegati tra loro attraverso il paper stesso: autore/i alla rivista, parole chiave alla data di pubblicazione, ecc. Alcune delle analisi descrittive viste in precedenza si possono visualizzare attraverso reti bipartite.


## Reti bipartite

Queste connessioni di diversi attributi generano reti bipartite che possono essere rappresentate come matrici rettangolari (Papers x Attributi).

Rete Paper x Fonte di pubblicazione:

```{r esempio bip}
manSource <- cocMatrix(newProva, Field = "SO", sep = ";", type = "matrix")
```

L'oggetto è una matrice binaria rettangolare che rappresenta una rete bipartita in cui le righe e le colonne sono, in questo caso, rispettivamente papers e fonti.

L'elemento generico $bip_{ij}$ è 1 se il paper i è stato pubblicato nella fonte j, 0 altrimenti.

La somma della colonna j-esima $bip_j$ rappresenta il numero di papers pubblicati nella fonte j.

Fonti di pubblicazione più rilevanti:

```{r bip source}
sort(Matrix::colSums(manSource), decreasing = TRUE)[1:5]
```


Rete degli autori: paper x autore, conta quanti articoli fatti da autori

```{r rete autori}
autNet <- cocMatrix(newProva, Field = "AU", sep = ";", type = "matrix")
sort(Matrix::colSums(autNet), decreasing = TRUE)[1:5]
```


## Accoppiamento bibliografico - autori

Le pubblicazioni scientifiche contengono riferimenti ad altri lavori scientifici. Questo genera un'altra rete, quella delle reti di accoppiamento o co-citazioni.

Due autori sono accoppiati bibliograficamente **se almeno una fonte citata compare nelle loro pubblicazioni**.
<!-- (papers A e B sono accoppiati bibliograficamente perchè hanno citato entrambi papers C, D, E) -->

Rete di accoppiamento: $$B = A\cdot A^T$$ dove A è una rete bipartita.  Due autori sono collegati da un arco nella rete se citano insieme uno o più documenti.

L'elemento $b_{i,j}$ indica quanti accoppiamenti bibliografici esistono tra i e j. La forza dell'accoppiamento di due autori, i e j, è definita dal numero di riferimenti che gli autori hanno in comune.

L'accoppiamento bibliografico tra autori è una misura di quanto due autori condividono riferimenti comuni nelle loro pubblicazioni. In altre parole, quanti autori citano gli stessi lavori nelle loro ricerche.

```{r accoppiamento autori}
autCoupNet <- biblioNetwork(newProva, analysis = "coupling", network = "authors", sep = ";")
netCoup = networkPlot(autCoupNet,  normalize = "association", weighted=NULL, n = 20, Title = "Authors' Coupling", type = "auto", size.cex=TRUE, remove.multiple=TRUE, labelsize=2, label.n=20, label.cex=TRUE, label.color = TRUE, halo = FALSE)
# Convertire la rete di Bibliometrix in un oggetto igraph
g1 <- graph_from_adjacency_matrix(autCoupNet, mode = "undirected", diag = FALSE)
#netCoup$nodeDegree
```

### Analisi della rete RIVEDERE BENE

Il nodo più centrale della rete risulta essere il Professor Montanari, con i valori più alti di tutti in queste tre metriche ^[Tutte le nozioni viste a lezione sono utilizzate ma non ri-definite.].

Il Professor Sciavicco si posiziona in alto per la betweenness centrality, indicando un ruolo di ponte tra diverse comunità di autori.

```{r net cluster centrality}
netCoup$cluster_res
```

```{r accop autori stat}
autCoupstat <- networkStat(autCoupNet)
summary(autCoupstat)
```

Densità: indica una rete sparsa.

Transitività: livello di clustering moderato.

Centralizzazione del grado: misura la concentrazione dei collegamenti nella rete, significa che la distribuzione dei gradi non è completamente uniforme, con alcuni autori che hanno un numero di collegamenti significativamente maggiore rispetto ad altri.

Lunghezza media dei percorsi: molto breve.

# Collaborazione autori

La rete di collaborazione scientifica è una rete in cui i nodi sono gli autori e i legami sono le coautorialità, in quanto quest'ultima è una delle forme più documentate di collaborazione scientifica (Glanzel, 2004).

Una rete di collaborazione tra autori può essere ottenuta utilizzando la formulazione generale: $$AC=A^T \cdot A$$ dove A è una rete bipartita Papers x Autori.

L'elemento diagonale $ac_i$ è il numero di papers di cui il ricercatore $i$ è autore o coautore.

```{r collaborazione aut}
autColl <- biblioNetwork(newProva, analysis = "collaboration", network = "authors", sep = ";")
autnetcoll = networkPlot(autColl,  normalize = "association", weighted=NULL, n = 30, Title = "Authors' Collaboration", type = "auto", size.cex=TRUE, remove.multiple=TRUE, labelsize=2, label.n=30, label.cex=TRUE, label.color = TRUE, halo = FALSE)
# Convertire la rete di Bibliometrix in un oggetto igraph
g <- graph_from_adjacency_matrix(autColl, mode = "undirected", diag = FALSE)

#autnetcoll$nodeDegree
```

Sono presenti 4 clusters ed in ognuno di essi è presente almeno un nodo con dei valori alti di centralità, il che indica un ruolo di connessione e influenza all'interno del cluster.

- cluster 1: Prof. Chittaro e Prof. Serra

- cluster 2: Prof. Dovier e Prof. Policriti

- cluster 3: Prof. Montanari

- cluster 4: Prof. Mizzaro e Prof. Della Mea


```{r autnetcoll cluster centrality}
#autnetcoll$cluster_res
```


```{r rete collab stat}
collabStat <- networkStat(autColl)
summary(collabStat)
```

Densità: rete molto sparsa.

Transitività: livello di clustering elevato.

Centralizzazione del grado: distribuzione dei gradi non è completamente uniforme, con alcuni autori che hanno un numero di collegamenti significativamente maggiore rispetto ad altri.

Lunghezza media dei percorsi: molto breve.


## Centralità dei nodi
```{r}
page_rank_result <- page_rank(g)


page_rank_values <- page_rank_result$vector

top_10_indices <- order(-page_rank_values)[1:10]
top_10_values <- page_rank_values[top_10_indices]
top_10_names <- names(top_10_values)


top_10_results <- data.frame(
  Author = top_10_names,
  PageRank = top_10_values
)

print(top_10_results)
```

I Prof. Mizzaro e Montanari sono i due autori con i valori di PageRank più alti; implica che sono nodi che hanno molti collegamenti da altri nodi potenzialmente centrali e parsimoniosi dal punto di vista dei collagamenti e sono anche probabilmente altamente collegati.

```{r}
as_tbl_graph(g) %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree(), closeness = centrality_closeness(), betweenness = centrality_betweenness(), eigen = centrality_eigen()) %>%
  select(name, degree, closeness, betweenness, eigen) %>%
  arrange(desc(degree), desc(closeness), desc(betweenness), desc(eigen)) %>%
  slice(1:10) %>%
  as_tibble()
```

Le altre misure di centralità (betweenness, che misura il numero di cammini più brevi che passano per un determinato nodo; closeness, che misura la distanza media da un nodo agli altri, e dell’autovettore, in cui un nodo è importante se è collegato ad altri nodi importanti) indicano che il nodo più centrale di questa rete è il Prof. Montanari.


## Power measure
Analizzo la misura di potenza, che dice che un nodo è potente se è connesso a nodi non potenti.

```{r}
library(lpSolve)
library(lpSolveAPI)

make_incidence = function(g) {
  n = vcount(g)
  m = ecount(g)
  # get edges as a matrix
  E = get.edges(g, E(g))
  B = matrix(0, nrow = n, ncol = m)
  # build incidence matrix
  for (i in 1:m) {
    B[E[i,1], i] = 1
    B[E[i,2], i] = 1
  }  
  return(B)
}

regularify = function (g) {
  n = vcount(g)
  m = ecount(g)
  B = make_incidence(g)
  # objective function
  obj = rep(0, m + 1)
  # constraint matrix
  con = cbind(B, rep(-1, n))
  # direction of constraints
  dir = rep("=", n)
  # right hand side terms
  rhs = -degree(g)
  # solve the LP problem
  sol = lp("max", obj, con, dir, rhs)
  # get solution
  if (sol$status == 0) {
    s = sol$solution
    # weights
    w = s[1:m] + 1
    # weighted degree
    d = s[m+1]
  }
  # return the solution
  if (sol$status == 0) {
    return(list(weights = w, degree = d)) 
  }
  else {
    return(NULL)   
  }
}
```


```{r power measure, echo=FALSE, results = 'hide'}
library(igraph)

regularify(g)

power <- function(A, t) {
  n <- dim(A)[1]
  x0 <- rep(0, n)
  x1 <- rep(1, n)
  x2 <- rep(1, n)
  diff <- 1
  eps <- 1/10^t
  iter <- 0
  epsilon <- 1e-10  # Aggiungere un piccolo valore per evitare divisioni per zero

  while (diff > eps) {
    x0 <- x1
    x1 <- x2
    x2 <- (1 / (x2 + epsilon)) %*% A  # Aggiungere epsilon a x2 per evitare divisioni per zero
    diff <- sum(abs(x2 - x0))
    iter <- iter + 1
  }
  
  alpha <- ((1 / (x2 + epsilon)) %*% A[,1]) / x2[1]
  x2 <- sqrt(alpha) %*% x2
  return(list(vector = as.vector(x2), iter = iter))
}

powerIter <- function(A, t, max_iter = 1000) {
  n <- dim(A)[1]
  x0 <- rep(0, n)
  x1 <- rep(1, n)
  x2 <- rep(1, n)
  diff <- 1
  eps <- 1 / 10^t
  iter <- 0
  epsilon <- 1e-10  # Aggiungere un piccolo valore per evitare divisioni per zero
  
  while (diff > eps && iter < max_iter) {
    x0 <- x1
    x1 <- x2
    x2 <- (1 / (x2 + epsilon)) %*% A  # Aggiungere epsilon a x2 per evitare divisioni per zero
    diff <- sum(abs(x2 - x0))
    iter <- iter + 1
  }
  
  alpha <- ((1 / (x2 + epsilon)) %*% A[,1]) / x2[1]
  x2 <- sqrt(alpha) %*% x2
  return(list(vector = as.vector(x2), iter = iter))
}


power_optimized <- function(A, t) {
  n <- dim(A)[1]
  x <- rep(1, n)
  epsilon <- 1e-10  # Aggiungere un piccolo valore per evitare divisioni per zero
  iter <- 0
  max_iter <- 1000  # Limitare il numero massimo di iterazioni
  
  repeat {
    x_old <- x
    x <- (1 / (x + epsilon)) %*% A
    x <- as.vector(x)
    
    # Calcolare la differenza relativa
    diff <- sum(abs(x - x_old)) / sum(abs(x_old))
    
    iter <- iter + 1
    
    if (diff < 1/10^t || iter >= max_iter) break
  }
  
  alpha <- ((1 / (x + epsilon)) %*% A[,1]) / x[1]
  x <- sqrt(alpha) * x
  
  return(list(vector = x, iter = iter))
}


# Convertire la matrice di adiacenza in una matrice normale
A <- as.matrix(get.adjacency(g))

# Use diagonal perturbation
Adj = as_adjacency_matrix(g)
I = diag(0.15, vcount(g))
(AI = Adj + I)

# Calcolare la misura di potenza
t_precision = 6  # Definire la precisione desiderata
power_result <- powerIter(A, t_precision)

power_values <- power_result$vector
num_iterations <- power_result$iter

#print(power_values)
#print(paste("Number of iterations:", num_iterations))

```


```{r}
author_names <- V(g)$name
author_power <- data.frame(Author = author_names, Power = power_values)
author_power <- author_power[order(-author_power$Power), ]
#print(author_power)

total_value <- sum(power_values)

percentage_values <- (power_values / total_value) * 100

author_names <- V(g)$name
author_power <- data.frame(Author = author_names, PowerPercentage = percentage_values)

author_power <- author_power[order(-author_power$PowerPercentage), ]

head(author_power)

correlation <- cor(power_values, degree(g))
print(correlation)

```

Ricavo che i nodi più potenti all'interno della rete delle collaborazioni sono il Prof. Miculan (13.8% del potere totale) e il Prof. Policriti (9.2% del potere totale).

Per ulteriore controllo, calcolo la correlazione tra il grado del nodo e il potere: 0.6162251; vuol dire che c'è una piccola correlazione.



# Analisi parole chiave

## Rete parole chiave

Rete Bipartita Papers x Keyword Scopus

Ogni paper ha associate delle parole chiave dal database di Scopus.

```{r rete keywords}
idNet <- cocMatrix(newProva, Field = "ID", sep = ";", type = "matrix")
parole <- sort(Matrix::colSums(idNet), decreasing = TRUE)[1:50]
#keyCount

keyword_data <- data.frame(
  word = names(parole),
  freq = parole
)

```

## Word cloud

Dai dati della rete bipartita è possibile creare un df con le frequenze delle parole, da cui si può ricavare una word cloud.

```{r save wordcloud}
library(DT)
saveWidget(wordcloud2(data = keyword_data, size = .4), "wordCloud3.html")
```


```{r word cloud, echo=FALSE}
htmltools::tags$iframe(title = "Word Cloud", src = "wordCloud3.html")
```

Le tre parole più presenti sono Computer Circuits (125), Semantics (101) e Temporal Logic (99).

## Rete co-occorrenze parole chiave

```{r rete cooc key}
# An example of a classical keyword co-occurrences network
coOc <- biblioNetwork(newProva, analysis = "co-occurrences", network = "keywords", sep = ";")
coOcNet = networkPlot(coOc,  normalize = "association", weighted=T, n = 30, Title = "Keywords Co-Occurrence", type = "fruchterman", size.cex=TRUE, remove.multiple=TRUE, labelsize=2, label.n=25, label.cex=TRUE, label.color = TRUE, halo = FALSE)
#coOcNet$nodeDegree
```

<!-- (pr centrality: misura l'importanza di un nodo nella rete in base ai collegamenti in entrata da altri nodi. Un nodo con un valore alto è considerato più importante o influente.) -->


Ci sono 2 cluster di parole chiave:

- nel primo, il nodo più centrale secondo le metriche di betweenness e closeness è "Mobile Devices"; mentre "Algorithms" risulta il nodo con centralità di autovettore e PageRank più alto;

- nel secondo, "Computer Programming" è il nodo con betweenness e clonesess più alta, mentre "Computer Circuits" ha centralità di autovettore e PageRank più alto. 


```{r coOcNet cluster centrality}
coOcNet$cluster_res
```


```{r rete cooc stat}
#coOcStat <- networkStat(coOc)
#summary(coOcStat, k = 10)
```


## Mappa tematica RIVEDERE

L'analisi di co-occorrenza delle parole chiave genera cluster tematici, la cui densità e centralità permettono di classificarli e mapparli in un diagramma bidimensionale, creando una mappa tematica. 

Essa consente di analizzare i temi in base al quadrante in cui sono collocati:

1. quadrante in alto a destra: temi motori (cluster molto denso e molto centrale);

2. quadrante in basso a destra: temi di base (cluster poco denso ma molto centrale);

3. quadrante in basso a sinistra: temi emergenti o in via di estinzione (cluster poco denso e poco centrale);

4. quadrante in alto a sinistra: temi molto specializzati/di nicchia (cluster molto denso e poco centrale).

```{r mappa tematica}
map <- thematicMap(newProva, field = "ID", n = 500, minfreq = 5)
plot(map$map)
#map$clusters
#map$words
```

La colonna r.rel si riferisce alle frequenze relative delle parole all'interno del cluster di appartenenza.

Ad esempio, il cluster in cui spicca la parola "algorithms" è nel quadrante dei temi di base, mentre "crowdsourcing" si trova nel quadrante dei temi emergenti o in declino. Il cluster con "finite element method" si trova nel quadrante dei temi di nicchia.

```{r cluster analysis}
clusters <-map$words %>%
  arrange(Cluster, desc(Occurrences))

clusters %>%
  select(Cluster, Words, Occurrences) %>%
  group_by(Cluster) %>%
  mutate(n.rel = Occurrences / sum(Occurrences) ) %>%
  slice(1:5)
```

# Conclusione RIFARE

<!-- nessuna rete ha una distribuzione dei nodi power-law, ma hanno lunghezza media dei cammini breve -->
All'interno del dipartimento operano gruppi di ricerca che si distinguono per una notevole produttività scientifica, la quale si traduce in un significativo apporto alla letteratura di settore. Pur focalizzandosi su ambiti di ricerca differenti, i gruppi collaborano attivamente tra loro, favorendo lo scambio di conoscenze e competenze.
